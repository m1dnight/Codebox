\documentclass[10pt,a4paper,BCOR12mm, headexclude, footexclude,
  twoside, openright]{scrartcl}
\usepackage[scaled]{helvet}
\usepackage[british]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{ifthen}
\usepackage{amsmath,amsfonts,amsthm}
\usepackage{sfmath}
\usepackage{makecell}
\usepackage{booktabs}
\usepackage{sectsty}
\usepackage{url} %url in footnote
\usepackage{color}
\usepackage{tikz}
\usepackage{graphicx}

%% Listings
\usepackage{listings}
\usepackage{xcolor}

\graphicspath{ {images/} }

%\KOMAoptions{optionenliste}
%\KOMAoptions{Option}{Werteliste}


\addtokomafont{caption}{\small}
%\setkomafont{descriptionlabel}{\normalfont
%   \bfseries}
\setkomafont{captionlabel}{\normalfont
    \bfseries}
\let\oldtabular\tabular
\renewcommand{\tabular}{\sffamily\oldtabular}
\KOMAoptions{abstract=true}
%\setkomafont{footnote}{\sffamily}
%\KOMAoptions{twoside=true}
%\KOMAoptions{headsepline=true}
%\KOMAoptions{footsepline=true}
\renewcommand\familydefault{\sfdefault}
\renewcommand{\arraystretch}{1.1}
\newcommand{\horrule}[1]{\rule{\linewidth}{#1}}
\setlength{\textheight}{230mm}
\allsectionsfont{\centering \normalfont\scshape}
\let\tmp\oddsidemargin
\let\oddsidemargin\evensidemargin
\let\evensidemargin\tmp
\reversemarginpar

\numberwithin{equation}{section} % Number equations within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{figure}{section} % Number figures within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{table}{section} % Number tables within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)

\setlength\parindent{0pt}

%%%% Listings
% C#
%\setmonofont{Consolas} %to be used with XeLaTeX or LuaLaTeX
\definecolor{bluekeywords}{rgb}{0,0,1}
\definecolor{greencomments}{rgb}{0,0.5,0}
\definecolor{redstrings}{rgb}{0.64,0.08,0.08}
\definecolor{xmlcomments}{rgb}{0.5,0.5,0.5}
\definecolor{types}{rgb}{0.17,0.57,0.68}

\usepackage{listings}
\lstset{language=[Sharp]C,
captionpos=b,
%numbers=left, %Nummerierung
%numberstyle=\tiny, % kleine Zeilennummern
frame=lines, % Oberhalb und unterhalb des Listings ist eine Linie
showspaces=false,
showtabs=false,
breaklines=true,
showstringspaces=false,
breakatwhitespace=true,
escapeinside={(*@}{@*)},
commentstyle=\color{greencomments},
morekeywords={partial, var, value, get, set},
keywordstyle=\color{bluekeywords},
stringstyle=\color{redstrings},
basicstyle=\ttfamily\small,
}

\begin{document}
%\sffamily
\fancypagestyle{plain}
{%
  \renewcommand{\headrulewidth}{0pt}%
  \renewcommand{\footrulewidth}{0.5pt}
  \fancyhf{}%
  \fancyfoot[R]{\emph{\footnotesize Page \thepage\ of \pageref{LastPage}}}%
  \fancyfoot[C]{\emph{\footnotesize Christophe De Troyer and Maarten Vandercammen}}%
}

\thispagestyle{plain}

\titlehead
{
    Vrije Universiteit Brussel\\%
    Pleinlaan 2\\%
    Software Languages Lab - Dept. Of Computer Science\hfill
    Master Studies%
}
\subject{\vspace{-1ex} \horrule{2pt}\\[0.15cm]
  {\textsc{\texttt{Capita Selecta: Software Engineering}}}}
\title{Project Software Engineering\\[0.5cm]}
\subtitle{\textsc{\texttt{Deliverable 1}}\\\horrule{2pt}\\[0.5cm]}
\author{
  \bfseries{Christophe De Troyer}\vspace{-2ex}
  \and
  \bfseries{Maarten Vandercammen}\vspace{-2ex} 
}
\date{\begin{tabular}{cc}
  \textsc{Date:}& \textsc{\emph{\today}}\\
  \textsc{Due :}& \textsc{\emph{17th June 2015}}\vspace{3ex}
\end{tabular}}
\maketitle

%-------------------------------
\fancypagestyle{plain}
{%
  \renewcommand{\headrulewidth}{0.5pt}%
  \renewcommand{\footrulewidth}{0.5pt}
  \fancyhf{}%
  \fancyhead[R]{\emph{\footnotesize \today}}
  \fancyfoot[R]{\emph{\footnotesize Page \thepage\ of \pageref{LastPage}}}%
  \fancyfoot[C]{\hspace*{-1.5cm} \emph{\footnotesize Christophe De Troyer} \hspace{2.7cm} \emph{\footnotesize Maarten Vandercammen} \\ \hspace*{-2cm} \emph{\footnotesize 106490} \hspace{4.5cm} \emph{\footnotesize 98341}}%
}

\pagestyle{plain}

\section{Detailed test strategy}

\subsection{Overview}
In this iteration, we develop all user-stories belonging to the third slice: the user-stories of the lowest priority. 
Specifically, these features are: uploading a profile picture, creating groups for users, editing these group and inviting other users into these groups.
These groups are used as a mechanism to share snippets with other users.
When creating a snippet, users can opt to share the snippet among all members of one or more specific groups.
This allows the other members of these groups to view this snippet. These members cannot edit or delete these snippets however.

\subsubsection*{Back-end tests}
In order to assure proper workings of the back-end it is needed to create unit tests that cover all of the controllers. Since this iteration will only implement features of the low priority slice only a single controller needs testing: the group controller.

\subsubsection*{GUI tests}
Similar to the first iteration, all GUI tests will be performed using the Selenium framework\footnote{http://www.seleniumhq.org/}.

Similar to the first iteration, we will perform all GUI testing from a black-box perspective, so that we can model a user's experience as accurately as possible.
Specifically, this means that we will avoid inserting or updating values, such as user accounts or code snippets, directly from the database wherever possible.
Instead, we will perform these actions through the webinterface, similar to how a user would accomplish this.
However, we will insert one user account, often referred to in this document as the \emph{central} user account, directly into the database, because most user-stories, e.g., creating, viewing or editing snippets, require the user to be logged in.
It would be undesirable to first register a user, log in with this new user account, perform the desired test and log out again, because these tests would then hinge completely on whether the 'Register' user-story succeeded.

We therefore choose to insert this user account directly into the database.

\subsection{User management}

\subsubsection*{Add profile picture}

Users can upload a profile picture which serves as their virtual avatar. This is performed by going to the edit page for their user account and uploading an image there.

We can create a GUI test for this user-story by logging in to our central user account, navigating to its profile edit page and uploading a valid, pre-existing image. If successful, a message should be displayed and the image should become visible as the user's online avatar.
All of these actions, including the uploading of the image and the verification of whether the avatar has been correctly altered, can be automated.
To verify that the new avatar is displayed correctly, we will calculate a hashsum of the avatar and compare it with the known hashsum associated with the image that was uploaded.
If both hashsums are the same, the images are also identical.

\subsection{Group management}

Writing back-end tests for all group management user stories is fairly trivial.
We therefore first discuss how these tests can be performed in general. Afterwards, we discuss how we can develop GUI tests for these features.

\subsubsection*{Back-end tests}
To make sure the group controller acts as it is supposed to it has to be tested on each function.
The group controller is used to create, edit and delete groups. As such, to achieve optimal coverage we will test all of these functions. 

The main strategy for testing is in line with the strategy that was applied to the other controllers. Test creating with correct data and faulty data. Deletion will be tested to make sure the user has appropriate authorization to remove.
Ensure that the deletion is actually performed and check that modifications are actually executed.

\subsubsection*{Create new group}

We will create GUI tests for this user-story. These tests will automatically log in to the central user, navigate to the group creation page, simulate the user's actions of creating a new group, e.g., entering an automatically generated name and description into the corresponding textboxes on this page, and click the 'Create' button.
A successful creation should cause this newly created group to be added to the overview page where all groups in which this central user is a member.
We will therefore test whether this new group, with the correct name and description, have been added.

We will also develop GUI tests that check how Codebox handles the case where the group that is to be created is invalid, e.g., because its name or description were left blank.
An invalid group creation should cause Codebox to show an appropriate error message. Testing these error messages can be done through selenium.

\subsubsection*{Invite user to group}

GUI tests will be created for this user-story.
To test this user-story we require the existence of at least two user accounts, because one user must invite the other into a group.
Our central user account can play the role of one of these users. The other role can be fulfilled by a newly created user.
We will therefore require a new user to be inserted into the database. This insertion will be performed directly, similar to how we created the central user account.

We also require the existence of at least one group, so that another user can be invited to this group. This group will either be created by directly inserting it into the database or by simply manually creating the group, before starting the development of the GUI tests.

Concretely, the GUI test for this user account will be implemented by letting the test log in using the central user account, navigate to the group page of the group that was created for this purpose and inviting the other user(s) by entering their e-mail address(es).
If the invitation is successful, a message should be displayed.
These actions can all be automated using Selenium.

We will also test an invalid group invitation, for example by entering a non-existing e-mail address and verifying whether the correct error message is displayed.

\subsubsection*{Edit group}

Editing a group can only be done by the user who created this group.
A GUI test for this user-story will be created by writing a test that automatically logs in to the central user account, creates a new group, navigates to this new group's edit page and alters some attributes.
When creation is successful, a message should appear and the group's attributes should be updated.
We verify whether this message did indeed appear, and we also navigate to the page where an overview is given of this group.
We can then check whether the attributes that are shown on this page correspond to the values of the attributes we just altered.

\section{Estimates}
Because the deadline for our master thesis is getting near, which greatly interferes with our work for this project, coming up with a detailed planning proved to be a challenging task.
We expect that this planning might be less accurate than the estimations we have created in previous iterations.

\subsection{Back-end tests}

\subsection{GUI tests}
Since no GUI tests have been written yet for the user-stories of group management, we expect to spend quite some time setting up some common auxiliary code that can be shared between all tests.
Furthermore, testing these features might require quite some work, because when a user is invited to a group, we must ensure that any new code snippet that is shared in this group, becomes visible to this user.
Testing this feature therefore requires us to switch between several users, always navigating to the correct page and subsequently ensuring that the snippet correctly shows up.

Furthermore, it might also prove somewhat complex to test GUI of the 'Upload profile picture' user-story, because we have to calculate an hashsum of the image that serves as the user's avatar.
We do not have any experience with performing such tasks in this framework, so we expect to spend a fair amount of time researching how this can be accomplished.

For these reasons, we plan on devoting three days to write all GUI tests.

\section{Evaluation of previous planning}
The planned tasks were executed within the set timeslot. As such we can safely
state that the previous planning was correct.
\subsection{Back-end Tests}
The planned tasks have been executed in the time we planned for them in the
previous deliverable. Again there was a small hurdle in the implementation of
the project that required refactoring. This time the
\texttt{CustomMembershiProvider} implemented \texttt{protected} methods. These
methods were thus not accessible from within the unit tests. As such a derived
class was created from the \texttt{CustomMembershipProvider} which publishes the
methods in a public fashion. Except that hurdle the tests were straightforward
as they were a variation on the previously written tests.

\subsection{GUI tests}
We planned on requiring one day and half of work for writing all GUI tests for the second iteration.
This estimation turned out to accurate to a certain extent. Because we could re-use quite a lot of code for testing the 'Edit account' and 'Edit snippet' stories from the GUI tests of respectively the 'Register' and 'Create new snippet' user-stories, we were able to shave off a decent amount of time.

We did not encounter any bugs whatsoever while running these tests, so we did not have to spend any time on fixing bugs.

However, we did spend an additional half-day on refactoring some of the testing code, so that it would be easier to re-use this code, not only for the second iteration, but other iterations as well.

\end{document}

\end{document}