\documentclass[10pt,a4paper,BCOR12mm, headexclude, footexclude,
  twoside, openright]{scrartcl}
\usepackage[scaled]{helvet}
\usepackage[british]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{ifthen}
\usepackage{amsmath,amsfonts,amsthm}
\usepackage{sfmath}
\usepackage{makecell}
\usepackage{booktabs}
\usepackage{sectsty}
\usepackage{url} %url in footnote
\usepackage{color}
\usepackage{tikz}
\usepackage{graphicx}

%% Listings
\usepackage{listings}
\usepackage{xcolor}

\graphicspath{ {images/} }

%\KOMAoptions{optionenliste}
%\KOMAoptions{Option}{Werteliste}


\addtokomafont{caption}{\small}
%\setkomafont{descriptionlabel}{\normalfont
%   \bfseries}
\setkomafont{captionlabel}{\normalfont
    \bfseries}
\let\oldtabular\tabular
\renewcommand{\tabular}{\sffamily\oldtabular}
\KOMAoptions{abstract=true}
%\setkomafont{footnote}{\sffamily}
%\KOMAoptions{twoside=true}
%\KOMAoptions{headsepline=true}
%\KOMAoptions{footsepline=true}
\renewcommand\familydefault{\sfdefault}
\renewcommand{\arraystretch}{1.1}
\newcommand{\horrule}[1]{\rule{\linewidth}{#1}}
\setlength{\textheight}{230mm}
\allsectionsfont{\centering \normalfont\scshape}
\let\tmp\oddsidemargin
\let\oddsidemargin\evensidemargin
\let\evensidemargin\tmp
\reversemarginpar

\numberwithin{equation}{section} % Number equations within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{figure}{section} % Number figures within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{table}{section} % Number tables within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)

\setlength\parindent{0pt}

%%%% Listings
% C#
%\setmonofont{Consolas} %to be used with XeLaTeX or LuaLaTeX
\definecolor{bluekeywords}{rgb}{0,0,1}
\definecolor{greencomments}{rgb}{0,0.5,0}
\definecolor{redstrings}{rgb}{0.64,0.08,0.08}
\definecolor{xmlcomments}{rgb}{0.5,0.5,0.5}
\definecolor{types}{rgb}{0.17,0.57,0.68}

\usepackage{listings}
\lstset{language=[Sharp]C,
captionpos=b,
%numbers=left, %Nummerierung
%numberstyle=\tiny, % kleine Zeilennummern
frame=lines, % Oberhalb und unterhalb des Listings ist eine Linie
showspaces=false,
showtabs=false,
breaklines=true,
showstringspaces=false,
breakatwhitespace=true,
escapeinside={(*@}{@*)},
commentstyle=\color{greencomments},
morekeywords={partial, var, value, get, set},
keywordstyle=\color{bluekeywords},
stringstyle=\color{redstrings},
basicstyle=\ttfamily\small,
}

\begin{document}
%\sffamily
\fancypagestyle{plain}
{%
  \renewcommand{\headrulewidth}{0pt}%
  \renewcommand{\footrulewidth}{0.5pt}
  \fancyhf{}%
  \fancyfoot[R]{\emph{\footnotesize Page \thepage\ of \pageref{LastPage}}}%
  \fancyfoot[C]{\emph{\footnotesize Christophe De Troyer and Maarten Vandercammen}}%
}

\thispagestyle{plain}

\titlehead
{
    Vrije Universiteit Brussel\\%
    Pleinlaan 2\\%
    Software Languages Lab - Dept. Of Computer Science\hfill
    Master Studies%
}
\subject{\vspace{-1ex} \horrule{2pt}\\[0.15cm]
  {\textsc{\texttt{Capita Selecta: Software Engineering}}}}
\title{Project Software Engineering\\[0.5cm]}
\subtitle{\textsc{\texttt{Deliverable 1}}\\\horrule{2pt}\\[0.5cm]}
\author{
  \bfseries{Christophe De Troyer}\vspace{-2ex}
  \and
  \bfseries{Maarten Vandercammen}\vspace{-2ex} 
}
\date{\begin{tabular}{cc}
  \textsc{Date:}& \textsc{\emph{\today}}\\
  \textsc{Due :}& \textsc{\emph{17th June 2015}}\vspace{3ex}
\end{tabular}}
\maketitle

%-------------------------------
\fancypagestyle{plain}
{%
  \renewcommand{\headrulewidth}{0.5pt}%
  \renewcommand{\footrulewidth}{0.5pt}
  \fancyhf{}%
  \fancyhead[R]{\emph{\footnotesize \today}}
  \fancyfoot[R]{\emph{\footnotesize Page \thepage\ of \pageref{LastPage}}}%
  \fancyfoot[C]{\hspace*{-1.5cm} \emph{\footnotesize Christophe De Troyer} \hspace{2.7cm} \emph{\footnotesize Maarten Vandercammen} \\ \hspace*{-2cm} \emph{\footnotesize 106490} \hspace{4.5cm} \emph{\footnotesize 98341}}%
}

\pagestyle{plain}

\section{Detailed test strategy}

\subsection{Overview}
In this iteration, we implement all user-stories that have the highest priority: registering a new user account, logging in and logging out, creating a new snippet and viewing an existing snippet.

We create both back-end tests for these user-stories, as well as automated GUI tests.

\subsubsection*{Back-end tests}
In order to assure proper workings of the back-end it is needed to create unit tests that cover all of the controllers.
Since this iteration will only implement features of the high priority slice only two controllers need proper testing: the account controller and the snippet controller.

\subsubsection*{GUI tests}
Unit-tests for the GUI of each user story will be created with the use of the Selenium framework \footnote{http://www.seleniumhq.org/}.
This framework can be used to simulate a user's interaction with the website. Specifically, it offers mechanisms to send mouse-clicks to DOM-elements, navigate a website, or send keyboard input through input forms.
Conversely, it also offers mechanisms to check the complete state of a DOM-element.
Creating automated GUI tests can then be accomplished by modelling the input that can be send by user and checking whether the DOM-elements which are expected to change have been correctly manipulated.

GUI tests consist of both valid actions performed by the user, such as successfully creating a new user account, logging in or creating new snippets, and invalid actions, such as logging in unsuccessfully, creating invalid snippets, etc.

In this project, all GUI tests will be written from a black-box perspective.
We believe that our GUI tests must accurately model a user's actions while using Codebox
 Although we aim to make the GUI tests fine-grained, we will not check the exact errors raised by the application. We only check how these errors are presented to the user.

\subsection{User management}

\subsubsection*{Log in}

\paragraph{Back-end tests}
To test the login process it requires some special testing.
The implementation notifies the user of a wrong password or wrong email address.
As such tests need to be written to assure that the system detects which piece of information is wrong: the username or the password and notifies the user as such. And finally we need to test that proper login also work.

\paragraph{GUI tests}
The result of the action of a user logging in can be categorized in three main scenario's: either the log-in was successful, either it was unsuccessful because a non-existing username was provided, or it was unsuccessful because an incorrect password was entered.
We will test these three scenario's with the use of Selenium.
We navigate to the home page of Codebox, navigate from there to the log-in page, find the DOM-elements that correspond with the textboxes where users enter their username and password, enter some credentials and subsequently click the 'Log in' button.
A successful log-in can be validated by checking whether the system redirected to the correct webpage and is showing the correct credentials.
An invalid log-in can be tested by checking whether the expected error message appears on the screen.
Since an error message is just another DOM-element, we can attempt to locate the error message and check whether it contains the expected text message.

The first scenario requires that at least one user account has already been created in Codebox, so that a log-in can be performed using this account.
For this reason, we will insert one or multiple user profiles directly into the database of Codebox and check whether it is possible to log in using the username and password of the respective users.
By inserting these profiles directly into the database, we can test the 'Log in' user-story separately from e.g., the 'Register' user-story.

\subsubsection*{Register}
\paragraph{Back-end tests}
To test the registration process one has to test the registration process.
However, this process is not contained within the controller but within the \texttt{Custom\-Member\-ship\-Provider}.
The only thing to test in the \texttt{HomeController} itself was a registration with proper credentials.

\paragraph{GUI tests}
From a high-level point of view, there are only two possible results when registering a new user account: either the registration succeeded or it failed.

Automatically testing a successful registration can be problematic, because the username of each account must be unique.
When testing the creation of a new account, we can therefore not simply hardcode the username that must be registered, since this test would always fail after it was run the first time.
The same holds for e-mail addresses
We therefore automatically generate a new, unique username and e-mail address every time we test a valid registration.
The actual test will be similar to how we test the 'Log in' user-story: we navigate from Codebox' homepage to the registration page, enter the generated username, e-mail address and password in their corresponding textboxes and click the 'Create' button.
A successful registration causes Codebox to redirect to the log-in page. We will therefore check whether this redirect has occurred, and if so, immediately try to log in using the credentials we just generated.

We will also test how unsuccessful registrations are handled by Codebox. We will test how Codebox handles registrations that use an already existing username or e-mail address, how it handles usernames or passwords that are considered too short, or how it handles the case where the textboxes containing the required information are empty when the user submits the form.

\subsubsection*{Log out}
\paragraph{Back-end tests}

\paragraph{GUI tests}
We will write GUI tests for logging out a user. Because each webpage that is shown by Codebox always contains a link in the upper-right corner to log out the user, we will write a GUI test that checks the expected behaviour when this link is clicked.
Logging out the user should result in a redirect to the home page of the application, so our test will check whether this redirect has indeed been performed.

\subsection{Snippet management}

\subsubsection*{Create new snippet}
\paragraph{Back-end tests}
To test the creation of snippets one has to check the validity of the input at the controller.
Hence, tests need to be created to edit snippets and to view snippets. The latter is a simple test to make sure the controller does a proper redirect or returns the proper snippet.
The former needs to verify the user can only request to edit or create snippets he has access to and that the edits are processed properly by the controller.
The storage of snippets can not be tested however. The application uses Entity Framework as its back-end and thus we find that this software should not be tested.

\paragraph{GUI tests}
We will again create unit-tests to check the creation of both valid and invalid snippets.
A valid snippet must have at least a name and a code fragment. The name of a snippet does not need to be unique.
To create a code snippet, the user must first be logged in.
A GUI test that checks the creation of a valid snippet must therefore also first simulate a user logging in.
To accomplish this, the test logs in into Codebox using a known user account. It then navigates to the correct webpage, enters values for the snippet to create, e.g., a name, a code fragment, description, programming language etc., and clicks the 'Save' button.

To check that the creation has succeeded and that the correct snippet was created, the test will then automatically navigate to the page where it expects this snippet to appear and compare the expected attributes of the snippet, i.e., the values that were just entered when creating this snippet, with the attributes that are visible on the snippet's webpage.
The attributes of a snippet are: its name, description, language, whether or not the snippet will be publicly visible, the groups in which this snippet will be shared and the actual code fragment.

This will cause some overlap between testing this user-story and testing the 'Show snippet' story because both tests involve viewing the attributes of a snippet.
A certain overlap between both user-stories seems unavoidable however, because in order to test whether the creation was completely successful, it is imperative that we test whether the correct attributes were selected.
If we stick to our principle of applying black-box testing for our GUI tests, then the only way of checking these attributes is by navigating to the correct snippet page and verifying whether the corresponding attributes are visible.

We will test the creation of multiple snippets, but it is of course infeasible to test for every combination of all values that can be given to the snippet's attributes.
We will however explore the range of values that can be given to each attribute, e.g., a short or a long name, code fragments consisting of multiple lines versus fragments consisting of only one line etc.
Every attribute can take an arbitrary value: it is entirely possible for a name or description to consist of non-alphabetical characters.

Apart from testing the creation of valid snippets, we also test how Codebox handles the creation of invalid snippets.
Specifically, we will test how the system handles the case where no name or code fragment is given to the snippet before submitting the creation form.
Currently, we foresee that not providing either of these attributes is the only possible cause of performing an unsuccessful snippet creation. 

\subsubsection*{Show snippet}
\paragraph{Back-end tests}

\paragraph{GUI tests}
Testing whether a snippet is displayed correctly can be performed by navigating to the webpage where the snippet is shown and comparing the snippet's attributes that are visible there with the known attributes of the snippet.
We therefore first need to create a number of snippets, so that we can test whether their attributes are correctly visualized.

One way to do this would be to automatically insert a number of snippets into the database but this would again go against our principal of only using black-box testing for he GUI tests.
We therefore automatically create a new snippet in each GUI test for this user-story, and subsequently navigate to the new snippet's webpage and automatically verify its attributes.
Since a snippet's attributes are visualized in the form of DOM-elements, verifying its attributes is simply a matter of checking whether the corresponding DOM-elements have the correct state.


\section{Estimates}
\subsection{Unit Tests}
The above described unit tests require the first initial setup and exploration
of the \texttt{Moq} framework and \texttt{Ninject}. As such we expect some
additional time to be spent on figuring out how everything will be done.

The unit tests should require half a day to setup and configure the sample data
and possible configuration. For the actual tests we will assume that one or two
full days should be enough to write all the tests. We predict that the testing
for the editing and listing each will be done in a single day. A day is planned
for each due to the fact that possible bugs may have to be fixed.
\subsection{Interface Tests}

\end{document}
